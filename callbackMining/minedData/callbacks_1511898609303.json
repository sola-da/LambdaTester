[
  {
    "callback": "function () {\n    window.onpopstate = onchange;\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function () {\n    if (event.propertyName === 'location') {\n        self.check();\n    }\n}",
    "receiverBase": "document",
    "receiverCallee": "attachEvent"
  },
  {
    "callback": "function () {\n    self.check();\n}",
    "receiverBase": "window",
    "receiverCallee": "setInterval"
  },
  {
    "callback": "function (route) {\n    var once = false;\n    return function () {\n        if (once)\n            return;\n        once = true;\n        return route.apply(this, arguments);\n    };\n}",
    "receiverBase": ""
  },
  {
    "callback": "function iterate() {\n    iterator(arr[completed], function (err) {\n        if (err || err === false) {\n            callback(err);\n            callback = function () {\n            };\n        } else {\n            completed += 1;\n            if (completed === arr.length) {\n                callback();\n            } else {\n                iterate();\n            }\n        }\n    });\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (err) {\n    if (err || err === false) {\n        callback(err);\n        callback = function () {\n        };\n    } else {\n        completed += 1;\n        if (completed === arr.length) {\n            callback();\n        } else {\n            iterate();\n        }\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "iterator"
  },
  {
    "callback": "function (p) {\n    self.on(method, p, route);\n}",
    "receiverBase": "path",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (m) {\n    self.on(m.toLowerCase(), path, route);\n}",
    "receiverBase": "method",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    if (callback) {\n        callback.apply(thisArg, arguments);\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "_asyncEverySeries"
  },
  {
    "callback": "function (p) {\n    return p && p.length > 0;\n}",
    "receiverBase": "path",
    "receiverCallee": "filter"
  },
  {
    "callback": "function ($compile, $rootScope) {\n    stateMock = { setBuilder: jasmine.createSpy('setBuilder') };\n    compile($compile, $rootScope);\n    expect(stateMock.setBuilder).toHaveBeenCalled();\n}",
    "receiverBase": "",
    "receiverCallee": "inject"
  },
  {
    "callback": "function ($compile, $rootScope) {\n    var spies = {};\n    stateMock = constructMock(spies);\n    compile($compile, $rootScope);\n    expect(spies['Item1'].parent).toBe('');\n    expect(spies['Item2'].parent).toBe('');\n    expect(spies['Item3'].parent).toBe('Item2');\n    expect(spies['Item4'].parent).toBe('Item2');\n    expect(spies['Item5'].parent).toBe('Item4');\n    expect(spies['Item6'].parent).toBe('');\n    expect(spies['Item7'].parent).toBe('Item6');\n}",
    "receiverBase": "",
    "receiverCallee": "inject"
  },
  {
    "callback": "function ($compile, $rootScope) {\n    var spies = {};\n    stateMock = constructMock(spies);\n    compile($compile, $rootScope);\n}",
    "receiverBase": "",
    "receiverCallee": "inject"
  },
  {
    "callback": "function (key) {\n    if (angular.isDefined($attrs[key]))\n        self.$options[key] = $attrs[key];\n}",
    "receiverBase": "angular",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (fn) {\n    fn();\n}",
    "receiverBase": "$viewChangeListeners",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    ngModelCtrl.$setViewValue(bsCollapseCtrl.$targets.$active);\n}",
    "receiverBase": "$viewChangeListeners",
    "receiverCallee": "push"
  },
  {
    "callback": "function (modelValue) {\n    if (bsCollapseCtrl.$targets.$active !== modelValue * 1) {\n        bsCollapseCtrl.$setActive(modelValue * 1);\n    }\n    return modelValue;\n}",
    "receiverBase": "$formatters",
    "receiverCallee": "push"
  },
  {
    "callback": "function () {\n    var index = attrs.bsCollapseToggle || bsCollapseCtrl.$toggles.indexOf(element);\n    bsCollapseCtrl.$setActive(index * 1);\n    scope.$apply();\n}",
    "receiverBase": "element",
    "receiverCallee": "on"
  },
  {
    "callback": "function () {\n    render();\n}",
    "receiverBase": "$viewChangeListeners",
    "receiverCallee": "push"
  },
  {
    "callback": "function (response) {\n    console.log(response);\n}",
    "receiverBase": "ajax",
    "receiverCallee": "done"
  },
  {
    "callback": "function () {\n    commandLine.showHint('Collaborate is off');\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function () {\n    var msg = 'To edit files in others projects you must have \\'collaborate\\' set to on.' + ' <a href=\"javascript:bespin.get(\\'settings\\').set(\\'collaborate\\', \\'on\\');\">Turn it on now</a>';\n    bespin.get('commandLine').showHint(msg, 10000);\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function (super_) {\n    inherits(SingleAssignmentDisposable, super_);\n    function SingleAssignmentDisposable() {\n        super_.call(this, true);\n    }\n    return SingleAssignmentDisposable;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (super_) {\n    inherits(SerialDisposable, super_);\n    function SerialDisposable() {\n        super_.call(this, false);\n    }\n    return SerialDisposable;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (state2) {\n    var isAdded = false, isDone = false, d = scheduler.scheduleWithState(state2, function (scheduler1, state3) {\n            if (isAdded) {\n                group.remove(d);\n            } else {\n                isDone = true;\n            }\n            recursiveAction(state3);\n            return disposableEmpty;\n        });\n    if (!isDone) {\n        group.add(d);\n        isAdded = true;\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "action"
  },
  {
    "callback": "function (scheduler1, state3) {\n    if (isAdded) {\n        group.remove(d);\n    } else {\n        isDone = true;\n    }\n    recursiveAction(state3);\n    return disposableEmpty;\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleWithState"
  },
  {
    "callback": "function (state2, dueTime1) {\n    var isAdded = false, isDone = false, d = scheduler[method].call(scheduler, state2, dueTime1, function (scheduler1, state3) {\n            if (isAdded) {\n                group.remove(d);\n            } else {\n                isDone = true;\n            }\n            recursiveAction(state3);\n            return disposableEmpty;\n        });\n    if (!isDone) {\n        group.add(d);\n        isAdded = true;\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "action"
  },
  {
    "callback": "function (scheduler1, state3) {\n    if (isAdded) {\n        group.remove(d);\n    } else {\n        isDone = true;\n    }\n    recursiveAction(state3);\n    return disposableEmpty;\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "call"
  },
  {
    "callback": "function () {\n    action();\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "schedulePeriodicWithState"
  },
  {
    "callback": "function () {\n    s = action(s);\n}",
    "receiverBase": "",
    "receiverCallee": "setInterval"
  },
  {
    "callback": "function () {\n    clearInterval(id);\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function (_action, self) {\n    _action(function () {\n        self(_action);\n    });\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "scheduleRecursiveWithState"
  },
  {
    "callback": "function () {\n    self(_action);\n}",
    "receiverBase": "",
    "receiverCallee": "_action"
  },
  {
    "callback": "function (s, p) {\n    return invokeRecImmediate(s, p);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "scheduleWithState"
  },
  {
    "callback": "function (_action, self) {\n    _action(function (dt) {\n        self(_action, dt);\n    });\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "scheduleRecursiveWithRelativeAndState"
  },
  {
    "callback": "function (dt) {\n    self(_action, dt);\n}",
    "receiverBase": "",
    "receiverCallee": "_action"
  },
  {
    "callback": "function (s, p) {\n    return invokeRecDate(s, p, 'scheduleWithRelativeAndState');\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_scheduleRelative"
  },
  {
    "callback": "function (_action, self) {\n    _action(function (dt) {\n        self(_action, dt);\n    });\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "scheduleRecursiveWithAbsoluteAndState"
  },
  {
    "callback": "function (dt) {\n    self(_action, dt);\n}",
    "receiverBase": "",
    "receiverCallee": "_action"
  },
  {
    "callback": "function (s, p) {\n    return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_scheduleAbsolute"
  },
  {
    "callback": "function () {\n    if (!disposable.isDisposed) {\n        disposable.setDisposable(action(scheduler, state));\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "scheduleMethod"
  },
  {
    "callback": "function () {\n    clearMethod(id);\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function () {\n    if (!disposable.isDisposed) {\n        disposable.setDisposable(action(scheduler, state));\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function () {\n    clearTimeout(id);\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function () {\n    notification._acceptObservable(observer);\n    if (notification.kind === 'N') {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "schedule"
  },
  {
    "callback": "function () {\n    self();\n}",
    "receiverBase": "current",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    isDisposed = true;\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function (exn) {\n    lastException = exn;\n    self();\n}",
    "receiverBase": "current",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    isDisposed = true;\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function () {\n    if (left === 0) {\n        return false;\n    }\n    if (left > 0) {\n        left--;\n    }\n    current = value;\n    return true;\n}",
    "receiverBase": "",
    "receiverCallee": "enumeratorCreate"
  },
  {
    "callback": "function () {\n    return current;\n}",
    "receiverBase": "",
    "receiverCallee": "enumeratorCreate"
  },
  {
    "callback": "function () {\n    if (++index < source.length) {\n        current = selector.call(thisArg, source[index], index, source);\n        return true;\n    }\n    return false;\n}",
    "receiverBase": "",
    "receiverCallee": "enumeratorCreate"
  },
  {
    "callback": "function () {\n    return current;\n}",
    "receiverBase": "",
    "receiverCallee": "enumeratorCreate"
  },
  {
    "callback": "function (x) {\n    hasValue = true;\n    value = x;\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (!hasValue) {\n        observer.onError(new Error(sequenceContainsNoElements));\n    } else {\n        observer.onNext(value);\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    self.observer.onNext(value);\n}",
    "receiverBase": "queue",
    "receiverCallee": "push"
  },
  {
    "callback": "function () {\n    self.observer.onError(exception);\n}",
    "receiverBase": "queue",
    "receiverCallee": "push"
  },
  {
    "callback": "function () {\n    self.observer.onCompleted();\n}",
    "receiverBase": "queue",
    "receiverCallee": "push"
  },
  {
    "callback": "function (self) {\n    var work;\n    if (parent.queue.length > 0) {\n        work = parent.queue.shift();\n    } else {\n        parent.isAcquired = false;\n        return;\n    }\n    try {\n        work();\n    } catch (ex) {\n        parent.queue = [];\n        parent.hasFaulted = true;\n        throw ex;\n    }\n    self();\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleRecursive"
  },
  {
    "callback": "function () {\n    observer.onCompleted();\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "schedule"
  },
  {
    "callback": "function (self) {\n    if (count < array.length) {\n        observer.onNext(array[count++]);\n        self();\n    } else {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleRecursive"
  },
  {
    "callback": "function (self) {\n    var hasResult, result;\n    try {\n        if (first) {\n            first = false;\n        } else {\n            state = iterate(state);\n        }\n        hasResult = condition(state);\n        if (hasResult) {\n            result = resultSelector(state);\n        }\n    } catch (exception) {\n        observer.onError(exception);\n        return;\n    }\n    if (hasResult) {\n        observer.onNext(result);\n        self();\n    } else {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleRecursive"
  },
  {
    "callback": "function (i, self) {\n    if (i < count) {\n        observer.onNext(start + i);\n        self(i + 1);\n    } else {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleRecursiveWithState"
  },
  {
    "callback": "function () {\n    observer.onNext(value);\n    observer.onCompleted();\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "schedule"
  },
  {
    "callback": "function () {\n    observer.onError(exception);\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "schedule"
  },
  {
    "callback": "function (exception) {\n    var d, result;\n    try {\n        result = handler(exception);\n    } catch (ex) {\n        observer.onError(ex);\n        return;\n    }\n    d = new SingleAssignmentDisposable();\n    subscription.setDisposable(d);\n    d.setDisposable(result.subscribe(observer));\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x, j) {\n    return j !== i;\n}",
    "receiverBase": "isDone",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (i) {\n    subscriptions[i] = new SingleAssignmentDisposable();\n    subscriptions[i].setDisposable(args[i].subscribe(function (x) {\n        values[i] = x;\n        next(i);\n    }, observer.onError.bind(observer), function () {\n        done(i);\n    }));\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (x) {\n    values[i] = x;\n    next(i);\n}",
    "receiverBase": "args",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    done(i);\n}",
    "receiverBase": "args",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    var s;\n    group.remove(subscription);\n    if (q.length > 0) {\n        s = q.shift();\n        subscribe(s);\n    } else {\n        activeCount--;\n        if (isStopped && activeCount === 0) {\n            observer.onCompleted();\n        }\n    }\n}",
    "receiverBase": "xs",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (innerSource) {\n    if (activeCount < maxConcurrentOrOther) {\n        activeCount++;\n        subscribe(innerSource);\n    } else {\n        q.push(innerSource);\n    }\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    isStopped = true;\n    if (activeCount === 0) {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (innerSource) {\n    var innerSubscription = new SingleAssignmentDisposable();\n    group.add(innerSubscription);\n    innerSubscription.setDisposable(innerSource.subscribe(function (x) {\n        observer.onNext(x);\n    }, observer.onError.bind(observer), function () {\n        group.remove(innerSubscription);\n        if (isStopped && group.length === 1) {\n            observer.onCompleted();\n        }\n    }));\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    observer.onNext(x);\n}",
    "receiverBase": "innerSource",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    group.remove(innerSubscription);\n    if (isStopped && group.length === 1) {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "innerSource",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    isStopped = true;\n    if (group.length === 1) {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (left) {\n    if (isOpen) {\n        observer.onNext(left);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (isOpen) {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    isOpen = true;\n    rightSubscription.dispose();\n}",
    "receiverBase": "other",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    rightSubscription.dispose();\n}",
    "receiverBase": "other",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    if (latest === id) {\n        observer.onNext(x);\n    }\n}",
    "receiverBase": "innerSource",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (e) {\n    if (latest === id) {\n        observer.onError(e);\n    }\n}",
    "receiverBase": "innerSource",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (latest === id) {\n        hasLatest = false;\n        if (isStopped) {\n            observer.onCompleted();\n        }\n    }\n}",
    "receiverBase": "innerSource",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    isStopped = true;\n    if (!hasLatest) {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (left) {\n    if (index < len) {\n        var right = second[index++], result;\n        try {\n            result = resultSelector(left, right);\n        } catch (e) {\n            observer.onError(e);\n            return;\n        }\n        observer.onNext(result);\n    } else {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "first",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    return [];\n}",
    "receiverBase": "",
    "receiverCallee": "arrayInitialize"
  },
  {
    "callback": "function () {\n    return false;\n}",
    "receiverBase": "",
    "receiverCallee": "arrayInitialize"
  },
  {
    "callback": "function (x) {\n    return x.length > 0;\n}",
    "receiverBase": "queues",
    "receiverCallee": "every"
  },
  {
    "callback": "function (x) {\n    return x.shift();\n}",
    "receiverBase": "queues",
    "receiverCallee": "map"
  },
  {
    "callback": "function (x, j) {\n    return j !== i;\n}",
    "receiverBase": "isDone",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (x) {\n    return x;\n}",
    "receiverBase": "isDone",
    "receiverCallee": "every"
  },
  {
    "callback": "function (i) {\n    subscriptions[i] = new SingleAssignmentDisposable();\n    subscriptions[i].setDisposable(sources[i].subscribe(function (x) {\n        queues[i].push(x);\n        next(i);\n    }, observer.onError.bind(observer), function () {\n        done(i);\n    }));\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (x) {\n    queues[i].push(x);\n    next(i);\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    done(i);\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    return [];\n}",
    "receiverBase": "",
    "receiverCallee": "arrayInitialize"
  },
  {
    "callback": "function () {\n    return false;\n}",
    "receiverBase": "",
    "receiverCallee": "arrayInitialize"
  },
  {
    "callback": "function (x) {\n    return x.length > 0;\n}",
    "receiverBase": "queues",
    "receiverCallee": "every"
  },
  {
    "callback": "function (x) {\n    return x.shift();\n}",
    "receiverBase": "queues",
    "receiverCallee": "map"
  },
  {
    "callback": "function (x, j) {\n    return j !== i;\n}",
    "receiverBase": "isDone",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (i) {\n    subscriptions[i] = new SingleAssignmentDisposable();\n    subscriptions[i].setDisposable(sources[i].subscribe(function (x) {\n        queues[i].push(x);\n        next(i);\n    }, observer.onError.bind(observer), function () {\n        done(i);\n    }));\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (x) {\n    queues[i].push(x);\n    next(i);\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    done(i);\n}",
    "receiverBase": "sources",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    for (var qIdx = 0, qLen = queues.length; qIdx < qLen; qIdx++) {\n        queues[qIdx] = [];\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function (x) {\n    return x.accept(observer);\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    try {\n        onNextFunc(x);\n    } catch (e) {\n        observer.onError(e);\n    }\n    observer.onNext(x);\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (exception) {\n    if (!onError) {\n        observer.onError(exception);\n    } else {\n        try {\n            onError(exception);\n        } catch (e) {\n            observer.onError(e);\n        }\n        observer.onError(exception);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (!onCompleted) {\n        observer.onCompleted();\n    } else {\n        try {\n            onCompleted();\n        } catch (e) {\n            observer.onError(e);\n        }\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    try {\n        subscription.dispose();\n    } catch (e) {\n        throw e;\n    } finally {\n        action();\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function (value) {\n    observer.onNext(notificationCreateOnNext(value));\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (e) {\n    observer.onNext(notificationCreateOnError(e));\n    observer.onCompleted();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    observer.onNext(notificationCreateOnCompleted());\n    observer.onCompleted();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    try {\n        if (!hasValue) {\n            hasValue = true;\n        }\n        if (hasAccumulation) {\n            accumulation = accumulator(accumulation, x);\n        } else {\n            accumulation = hasSeed ? accumulator(seed, x) : x;\n            hasAccumulation = true;\n        }\n    } catch (e) {\n        observer.onError(e);\n        return;\n    }\n    observer.onNext(accumulation);\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (!hasValue && hasSeed) {\n        observer.onNext(seed);\n    }\n    observer.onCompleted();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    q.push(x);\n    if (q.length > count) {\n        observer.onNext(q.shift());\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (xs) {\n    return observableFromArray(xs, scheduler);\n}",
    "receiverBase": "takeLastBuffer",
    "receiverCallee": "selectMany"
  },
  {
    "callback": "function (x) {\n    q.push(x);\n    if (q.length > count) {\n        q.shift();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    observer.onNext(q);\n    observer.onCompleted();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (value) {\n    var result;\n    try {\n        result = selector.call(thisArg, value, count++, parent);\n    } catch (exception) {\n        observer.onError(exception);\n        return;\n    }\n    observer.onNext(result);\n}",
    "receiverBase": "parent",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    return selector(x).select(function (y) {\n        return resultSelector(x, y);\n    });\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "selectMany"
  },
  {
    "callback": "function (y) {\n    return resultSelector(x, y);\n}",
    "receiverBase": "selector",
    "receiverCallee": "select"
  },
  {
    "callback": "function () {\n    return selector;\n}",
    "receiverBase": "selectMany",
    "receiverCallee": "call"
  },
  {
    "callback": "function (x) {\n    if (remaining <= 0) {\n        observer.onNext(x);\n    } else {\n        remaining--;\n    }\n}",
    "receiverBase": "observable",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    if (!running) {\n        try {\n            running = !predicate.call(thisArg, x, i++, source);\n        } catch (e) {\n            observer.onError(e);\n            return;\n        }\n    }\n    if (running) {\n        observer.onNext(x);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    if (remaining > 0) {\n        remaining--;\n        observer.onNext(x);\n        if (remaining === 0) {\n            observer.onCompleted();\n        }\n    }\n}",
    "receiverBase": "observable",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    if (running) {\n        try {\n            running = predicate.call(thisArg, x, i++, observable);\n        } catch (e) {\n            observer.onError(e);\n            return;\n        }\n        if (running) {\n            observer.onNext(x);\n        } else {\n            observer.onCompleted();\n        }\n    }\n}",
    "receiverBase": "observable",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (value) {\n    var shouldRun;\n    try {\n        shouldRun = predicate.call(thisArg, value, count++, parent);\n    } catch (exception) {\n        observer.onError(exception);\n        return;\n    }\n    if (shouldRun) {\n        observer.onNext(value);\n    }\n}",
    "receiverBase": "parent",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    element.removeListener(name, handler);\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function () {\n    element.removeEventListener(name, handler, false);\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function handler(e) {\n    var results = e;\n    if (selector) {\n        try {\n            results = selector(arguments);\n        } catch (err) {\n            observer.onError(err);\n            return;\n        }\n    }\n    observer.onNext(results);\n}",
    "receiverBase": "",
    "receiverCallee": "createEventListener"
  },
  {
    "callback": "function () {\n    if (removeHandler) {\n        removeHandler(innerHandler, returnValue);\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function (value) {\n    observer.onNext(value);\n    observer.onCompleted();\n}",
    "receiverBase": "promise",
    "receiverCallee": "then"
  },
  {
    "callback": "function (reason) {\n    observer.onError(reason);\n}",
    "receiverBase": "promise",
    "receiverCallee": "then"
  },
  {
    "callback": "function () {\n    return new Subject();\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "multicast"
  },
  {
    "callback": "function () {\n    return new AsyncSubject();\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "multicast"
  },
  {
    "callback": "function () {\n    return new BehaviorSubject(initialValue);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "multicast"
  },
  {
    "callback": "function () {\n    return new ReplaySubject(bufferSize, window, scheduler);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "multicast"
  },
  {
    "callback": "function () {\n    state.hasSubscription = false;\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function () {\n    subscription.dispose();\n    count--;\n    if (count === 0) {\n        connectableSubscription.dispose();\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "disposableCreate"
  },
  {
    "callback": "function () {\n    observer.onNext(0);\n    observer.onCompleted();\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleWithRelative"
  },
  {
    "callback": "function (count) {\n    observer.onNext(count);\n    return count + 1;\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "schedulePeriodicWithState"
  },
  {
    "callback": "function () {\n    return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);\n}",
    "receiverBase": "",
    "receiverCallee": "observableDefer"
  },
  {
    "callback": "function () {\n    return observableTimer(dueTime, scheduler);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "throttleWithSelector"
  },
  {
    "callback": "function () {\n    var last = scheduler.now();\n    return source.select(function (x) {\n        var now = scheduler.now(), span = now - last;\n        last = now;\n        return {\n            value: x,\n            interval: span\n        };\n    });\n}",
    "receiverBase": "",
    "receiverCallee": "observableDefer"
  },
  {
    "callback": "function (x) {\n    var now = scheduler.now(), span = now - last;\n    last = now;\n    return {\n        value: x,\n        interval: span\n    };\n}",
    "receiverBase": "source",
    "receiverCallee": "select"
  },
  {
    "callback": "function (x) {\n    return {\n        value: x,\n        timestamp: scheduler.now()\n    };\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "select"
  },
  {
    "callback": "function (newValue) {\n    hasValue = true;\n    value = newValue;\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    atEnd = true;\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    switched = id === myId;\n    var timerWins = switched;\n    if (timerWins) {\n        subscription.setDisposable(other.subscribe(observer));\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "schedulerMethod"
  },
  {
    "callback": "function (x) {\n    var onNextWins = !switched;\n    if (onNextWins) {\n        id++;\n        observer.onNext(x);\n        createTimer();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (e) {\n    var onErrorWins = !switched;\n    if (onErrorWins) {\n        id++;\n        observer.onError(e);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    var onCompletedWins = !switched;\n    if (onCompletedWins) {\n        id++;\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    return observableEmpty();\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "delayWithSelector"
  },
  {
    "callback": "function (x) {\n    var delay;\n    try {\n        delay = selector(x);\n    } catch (error) {\n        observer.onError(error);\n        return;\n    }\n    var d = new SingleAssignmentDisposable();\n    delays.add(d);\n    d.setDisposable(delay.subscribe(function () {\n        observer.onNext(x);\n        delays.remove(d);\n        done();\n    }, observer.onError.bind(observer), function () {\n        observer.onNext(x);\n        delays.remove(d);\n        done();\n    }));\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    observer.onNext(x);\n    delays.remove(d);\n    done();\n}",
    "receiverBase": "delay",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    observer.onNext(x);\n    delays.remove(d);\n    done();\n}",
    "receiverBase": "delay",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    atEnd = true;\n    subscription.dispose();\n    done();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    start();\n}",
    "receiverBase": "subDelay",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    start();\n}",
    "receiverBase": "subDelay",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (timerWins()) {\n        subscription.setDisposable(other.subscribe(observer));\n    }\n    d.dispose();\n}",
    "receiverBase": "timeout",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (e) {\n    if (timerWins()) {\n        observer.onError(e);\n    }\n}",
    "receiverBase": "timeout",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (timerWins()) {\n        subscription.setDisposable(other.subscribe(observer));\n    }\n}",
    "receiverBase": "timeout",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    if (observerWins()) {\n        observer.onNext(x);\n        var timeout;\n        try {\n            timeout = timeoutdurationSelector(x);\n        } catch (e) {\n            observer.onError(e);\n            return;\n        }\n        setTimer(timeout);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (e) {\n    if (observerWins()) {\n        observer.onError(e);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (observerWins()) {\n        observer.onCompleted();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (hasValue && id === currentid) {\n        observer.onNext(value);\n    }\n    hasValue = false;\n    d.dispose();\n}",
    "receiverBase": "throttle",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    if (hasValue && id === currentid) {\n        observer.onNext(value);\n    }\n    hasValue = false;\n    d.dispose();\n}",
    "receiverBase": "throttle",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (e) {\n    cancelable.dispose();\n    observer.onError(e);\n    hasValue = false;\n    id++;\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    cancelable.dispose();\n    if (hasValue) {\n        observer.onNext(value);\n    }\n    observer.onCompleted();\n    hasValue = false;\n    id++;\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (x) {\n    var now = scheduler.now();\n    q.push({\n        interval: now,\n        value: x\n    });\n    while (q.length > 0 && now - q[0].interval >= duration) {\n        observer.onNext(q.shift().value);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    var now = scheduler.now();\n    while (q.length > 0 && now - q[0].interval >= duration) {\n        observer.onNext(q.shift().value);\n    }\n    observer.onCompleted();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (xs) {\n    return observableFromArray(xs, loopScheduler);\n}",
    "receiverBase": "takeLastBufferWithTime",
    "receiverCallee": "selectMany"
  },
  {
    "callback": "function (x) {\n    var now = scheduler.now();\n    q.push({\n        interval: now,\n        value: x\n    });\n    while (q.length > 0 && now - q[0].interval >= duration) {\n        q.shift();\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    var now = scheduler.now(), res = [];\n    while (q.length > 0) {\n        var next = q.shift();\n        if (now - next.interval <= duration) {\n            res.push(next.value);\n        }\n    }\n    observer.onNext(res);\n    observer.onCompleted();\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    observer.onCompleted();\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleWithRelative"
  },
  {
    "callback": "function () {\n    open = true;\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleWithRelative"
  },
  {
    "callback": "function (x) {\n    if (open) {\n        observer.onNext(x);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    open = true;\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleWithAbsolute"
  },
  {
    "callback": "function (x) {\n    if (open) {\n        observer.onNext(x);\n    }\n}",
    "receiverBase": "source",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function () {\n    observer.onCompleted();\n}",
    "receiverBase": "scheduler",
    "receiverCallee": "scheduleWithAbsolute"
  },
  {
    "callback": "function () {\n    try {\n        autoDetachObserver.setDisposable(fixSubscriber(subscribe(autoDetachObserver)));\n    } catch (e) {\n        if (!autoDetachObserver.fail(e)) {\n            throw e;\n        }\n    }\n}",
    "receiverBase": "currentThreadScheduler",
    "receiverCallee": "schedule"
  },
  {
    "callback": "function () {\n    return Rx;\n}",
    "receiverBase": "",
    "receiverCallee": "define"
  },
  {
    "callback": "function () {\n    expect(scope.quizIndex).toBe(0);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    expect(scope.isAnswerVisible).toBe(false);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    expect(scope.isQuizEnd).toBe(false);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    expect(scope.isQuizEmpty).toBe(false);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    it('should return the first word', function () {\n        expect(scope.getCurrentWord()).toBe(word1);\n    });\n    it('should return the second word', function () {\n        scope.quizIndex = 1;\n        expect(scope.getCurrentWord()).toBe(word2);\n    });\n}",
    "receiverBase": "",
    "receiverCallee": "describe"
  },
  {
    "callback": "function () {\n    expect(scope.getCurrentWord()).toBe(word1);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    scope.quizIndex = 1;\n    expect(scope.getCurrentWord()).toBe(word2);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    scope.goNextWord();\n    expect(scope.quizIndex).toBe(1);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    scope.isAnswerVisible = true;\n    scope.goNextWord();\n    expect(scope.isAnswerVisible).toBe(false);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    scope.goNextWord();\n    expect(scope.isQuizEnd).toBe(false);\n    scope.goNextWord();\n    expect(scope.isQuizEnd).toBe(true);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    it('should set the answer visibility to true', function () {\n        scope.showAnswer();\n        expect(scope.isAnswerVisible).toBe(true);\n    });\n}",
    "receiverBase": "",
    "receiverCallee": "describe"
  },
  {
    "callback": "function () {\n    scope.showAnswer();\n    expect(scope.isAnswerVisible).toBe(true);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    it('should increment the number of success of the word', function () {\n        var actualWord = scope.getCurrentWord();\n        scope.markAsKnown();\n        expect(wordsDataServiceMock.incrementSuccess).toHaveBeenCalledWith(actualWord);\n    });\n    it('should go to next word', function () {\n        scope.goNextWord = jasmine.createSpy();\n        scope.markAsKnown();\n        expect(scope.goNextWord).toHaveBeenCalled();\n    });\n}",
    "receiverBase": "",
    "receiverCallee": "describe"
  },
  {
    "callback": "function () {\n    var actualWord = scope.getCurrentWord();\n    scope.markAsKnown();\n    expect(wordsDataServiceMock.incrementSuccess).toHaveBeenCalledWith(actualWord);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    scope.goNextWord = jasmine.createSpy();\n    scope.markAsKnown();\n    expect(scope.goNextWord).toHaveBeenCalled();\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    it('should decrement the number of success of the word', function () {\n        var actualWord = scope.getCurrentWord();\n        scope.markAsUnknown();\n        expect(wordsDataServiceMock.decrementSuccess).toHaveBeenCalledWith(actualWord);\n    });\n    it('should go to next word', function () {\n        scope.goNextWord = jasmine.createSpy();\n        scope.markAsUnknown();\n        expect(scope.goNextWord).toHaveBeenCalled();\n    });\n}",
    "receiverBase": "",
    "receiverCallee": "describe"
  },
  {
    "callback": "function () {\n    var actualWord = scope.getCurrentWord();\n    scope.markAsUnknown();\n    expect(wordsDataServiceMock.decrementSuccess).toHaveBeenCalledWith(actualWord);\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function () {\n    scope.goNextWord = jasmine.createSpy();\n    scope.markAsUnknown();\n    expect(scope.goNextWord).toHaveBeenCalled();\n}",
    "receiverBase": "",
    "receiverCallee": "it"
  },
  {
    "callback": "function (e) {\n    tmp.push(e);\n}",
    "receiverBase": "edges",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (e) {\n    e.subdivide();\n}",
    "receiverBase": "tmp",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (edg) {\n    newPath.addEdge(edg.duplicate());\n}",
    "receiverBase": "edges",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (v) {\n    this.addEdge(v.duplicate());\n}",
    "receiverBase": "edges",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (i) {\n    new Wymeditor($(this), options);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "each"
  },
  {
    "callback": "function (e) {\n    if (e.keyCode == 13 && !e.shiftKey) {\n        $(elem).after('<p></p>');\n        $('.wym_box').remove();\n    } else {\n        $(elem).html($(this).val());\n        wymeditor.html = $(elem).html();\n        $('.wym_html').val($('body').html());\n    }\n}",
    "receiverBase": "$",
    "receiverCallee": "keyup"
  },
  {
    "callback": "function () {\n    resultParentDiv.focus();\n}",
    "receiverBase": "window",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function () {\n    spanHolder.click();\n}",
    "receiverBase": "link",
    "receiverCallee": "addEventListener"
  },
  {
    "callback": "function () {\n    spanHolder.click();\n}",
    "receiverBase": "",
    "receiverCallee": "_connect"
  },
  {
    "callback": "function (child) {\n    var childRow = this.explorer.getRow(child);\n    childRow.parentNode.removeChild(childRow);\n}",
    "receiverBase": "children",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (item) {\n    var emptyKeyword = false;\n    if (that.model._provideSearchHelper && that.model._provideSearchHelper().params.keyword === '') {\n        emptyKeyword = true;\n    }\n    return !item._reporting && !emptyKeyword;\n}",
    "receiverBase": "mExplorer",
    "receiverCallee": "createExplorerCommands"
  },
  {
    "callback": "function (error) {\n    return { _error: error };\n}",
    "receiverBase": "Deferred",
    "receiverCallee": "all"
  },
  {
    "callback": "function () {\n    that.refreshValidFiles();\n}",
    "receiverBase": "staleCheck",
    "receiverCallee": "then"
  },
  {
    "callback": "function (element) {\n    if (currentModel.location === element.location) {\n        return true;\n    } else if (element.checked) {\n        changeIndex++;\n    }\n    return false;\n}",
    "receiverBase": "children",
    "receiverCallee": "some"
  },
  {
    "callback": "function () {\n    that.refreshValidFiles();\n}",
    "receiverBase": "staleCheck",
    "receiverCallee": "then"
  }
]