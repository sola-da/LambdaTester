[
  {
    "callback": "function (Theme, themes) {\n    themes.Desert = new Theme({\n        colors: [\n            '#ffebd5',\n            '#806544',\n            '#fdc888',\n            '#80766b',\n            '#cda26e'\n        ]\n    });\n    return themes.Desert;\n}",
    "receiverBase": "",
    "receiverCallee": "define"
  },
  {
    "callback": "function () {\n    return this._scope || this.parent.scope;\n}",
    "receiverBase": "prototype",
    "receiverCallee": "__defineGetter__"
  },
  {
    "callback": "function () {\n    'use strict';\n    var db = require('org/arangodb').db, collname = applicationContext.collectionName('questions'), collection = db._collection(collname);\n    if (collection !== null) {\n        collection.drop();\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (global, definition) {\n    var def = function () {\n        return definition(global);\n    };\n    if (typeof exports === 'object' && typeof module === 'object') {\n        module.exports = def();\n    } else if (typeof define === 'function' && define['amd']) {\n        define(def);\n    } else {\n        breeze = def();\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function () {\n    try {\n        return !!Object.getPrototypeOf && Object.defineProperty({}, 'x', {});\n    } catch (e) {\n        return false;\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (propName) {\n    target[propName] = source[propName];\n}",
    "receiverBase": "propNames",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (o) {\n    return __toJSONSafe(o, replacer);\n}",
    "receiverBase": "obj",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pn) {\n    for (var i = 0; i < length; i++) {\n        var src = sources[i];\n        if (src) {\n            var val = src[pn];\n            if (val !== undefined) {\n                r[pn] = val;\n                break;\n            }\n        }\n    }\n}",
    "receiverBase": "propertyNames",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (v, ix) {\n    var r = fn(v, ix);\n    if (r != null || includeNull) {\n        result[ix] = r;\n    }\n}",
    "receiverBase": "items",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 3 | 8;\n    return v.toString(16);\n}",
    "receiverBase": "LIT:xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx",
    "receiverCallee": "replace"
  },
  {
    "callback": "function (match, index) {\n    return args[index];\n}",
    "receiverBase": "string",
    "receiverCallee": "replace"
  },
  {
    "callback": "function (v1) {\n    return prevContext.fn(prevContext, v1);\n}",
    "receiverBase": "v",
    "receiverCallee": "every"
  },
  {
    "callback": "function (context) {\n    return context.fn(context, self.v);\n}",
    "receiverBase": "contexts",
    "receiverCallee": "some"
  },
  {
    "callback": "function (context) {\n    return getMessage(context, that.v);\n}",
    "receiverBase": "_contexts",
    "receiverCallee": "map"
  },
  {
    "callback": "function (p) {\n    if (!allowUnknownProperty)\n        delete clone[p.name];\n    try {\n        p.check();\n    } catch (e) {\n        throwConfigError(instance, e.message);\n    }\n    !checkOnly && p._applyOne(instance);\n}",
    "receiverBase": "params",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key) {\n    prototype[key] = methodObj[key];\n}",
    "receiverBase": "keys",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key) {\n    newSymbol[key] = propertiesObj[key];\n}",
    "receiverBase": "keys",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    newSymbol.getName();\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function (sym) {\n    return sym.getName();\n}",
    "receiverBase": "getSymbols",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key) {\n    return this[key];\n}",
    "receiverBase": "getNames",
    "receiverCallee": "map"
  },
  {
    "callback": "function (name) {\n    return that.parentEnum[name] === that;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (s) {\n    try {\n        s.callback(data);\n    } catch (e) {\n        e.context = 'unable to publish on topic: ' + that.name;\n        if (errorCallback) {\n            errorCallback(e);\n        } else if (that._defaultErrorCallback) {\n            that._defaultErrorCallback(e);\n        } else {\n            fallbackErrorHandler(e);\n        }\n    }\n}",
    "receiverBase": "subscribers",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (s) {\n    return s.unsubKey === unsubKey;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayIndexOf"
  },
  {
    "callback": "function () {\n    return true;\n}",
    "receiverBase": "",
    "receiverCallee": "__objectFirst"
  },
  {
    "callback": "function (interfaceInitializedArgs) {\n    instance.checkForRecomposition(interfaceInitializedArgs);\n}",
    "receiverBase": "interfaceInitialized",
    "receiverCallee": "subscribe"
  },
  {
    "callback": "function (k, v) {\n    return k.toLowerCase() === lcName;\n}",
    "receiverBase": "",
    "receiverCallee": "__objectFirst"
  },
  {
    "callback": "function () {\n    publisher[eventName].publish(publisher._pendingArgs);\n    publisher._pendingArgs = null;\n}",
    "receiverBase": "pendingPubs",
    "receiverCallee": "push"
  },
  {
    "callback": "function (js) {\n    return ctor.fromJSON(js);\n}",
    "receiverBase": "json",
    "receiverCallee": "map"
  },
  {
    "callback": "function () {\n    return validator;\n}",
    "receiverBase": "__config",
    "receiverCallee": "registerFunction"
  },
  {
    "callback": "function (key, value) {\n    if (typeof value !== 'function') {\n        return;\n    }\n    if (key === 'fromJSON' || key === 'register' || key === 'registerFactory' || key === 'makeRegExpValidator') {\n        return;\n    }\n    __config.registerFunction(value, 'Validator.' + key);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (_, key) {\n    var valOrFn;\n    if (ownPropertiesOnly) {\n        valOrFn = vars.hasOwnProperty(key) ? vars[key] : '';\n    } else {\n        valOrFn = vars[key];\n    }\n    if (valOrFn != null) {\n        if (__isFunction(valOrFn)) {\n            return valOrFn(vars);\n        } else {\n            return valOrFn;\n        }\n    } else {\n        return '';\n    }\n}",
    "receiverBase": "template",
    "receiverCallee": "replace"
  },
  {
    "callback": "function (co) {\n    clearAspect(co, that);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (co) {\n    that.push(co);\n}",
    "receiverBase": "_origValues",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (a) {\n    return a.parent !== complexArray.parent;\n}",
    "receiverBase": "adds",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (a) {\n    if (a.parent != null) {\n        throw new Error('The complexObject is already attached. Either clone it or remove it from its current owner');\n    }\n    setAspect(a, complexArray);\n}",
    "receiverBase": "adds",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (a) {\n    clearAspect(a, complexArray);\n}",
    "receiverBase": "removes",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    return this.entityManager;\n}",
    "receiverBase": "Event",
    "receiverCallee": "bubbleEvent"
  },
  {
    "callback": "function (p) {\n    return this.entity.getProperty(p.name);\n}",
    "receiverBase": "keyProps",
    "receiverCallee": "map"
  },
  {
    "callback": "function () {\n    rejectChangesCore(entity);\n}",
    "receiverBase": "",
    "receiverCallee": "__using"
  },
  {
    "callback": "function (cp) {\n    var cos = target.getProperty(cp.name);\n    if (cp.isScalar) {\n        rejectChangesCore(cos);\n    } else {\n        cos._rejectChanges();\n        cos.forEach(rejectChangesCore(co));\n    }\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (cp) {\n    var cos = target.getProperty(cp.name);\n    if (cp.isScalar) {\n        clearOriginalValues(cos);\n    } else {\n        cos._acceptChanges();\n        cos.forEach(function (co) {\n            clearOriginalValues(co);\n        });\n    }\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (co) {\n    clearOriginalValues(co);\n}",
    "receiverBase": "cos",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (data) {\n    that._markAsLoaded(navProperty.name);\n    if (callback)\n        callback(data);\n    return Q.resolve(data);\n}",
    "receiverBase": "promise",
    "receiverCallee": "then"
  },
  {
    "callback": "function (error) {\n    if (errorCallback)\n        errorCallback(error);\n    return Q.reject(error);\n}",
    "receiverBase": "promise",
    "receiverCallee": "then"
  },
  {
    "callback": "function (that) {\n    ok = validateTarget(that.entity);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_processValidationOpAndPublish"
  },
  {
    "callback": "function (pv, cv, ix) {\n    return validateTarget(cv, ix) && pv;\n}",
    "receiverBase": "value",
    "receiverCallee": "reduce"
  },
  {
    "callback": "function (validator) {\n    ok = validate(entityAspect, validator, target) && ok;\n}",
    "receiverBase": "getAllValidators",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (ve) {\n    return ve.property && (ve.property.name === propertyName || propertyName.indexOf('.') != -1 && ve.propertyName == propertyName);\n}",
    "receiverBase": "result",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (that) {\n    that._addValidationError(validationError);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_processValidationOpAndPublish"
  },
  {
    "callback": "function (that) {\n    that._removeValidationError(key);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_processValidationOpAndPublish"
  },
  {
    "callback": "function (that) {\n    __objectForEach(that._validationErrors, function (key, valError) {\n        if (valError) {\n            delete that._validationErrors[key];\n            that._pendingValidationResult.removed.push(valError);\n        }\n    });\n    that.hasValidationErrors = !__isEmpty(that._validationErrors);\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_processValidationOpAndPublish"
  },
  {
    "callback": "function (key, valError) {\n    if (valError) {\n        delete that._validationErrors[key];\n        that._pendingValidationResult.removed.push(valError);\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (fkn) {\n    return that.entity.getProperty(fkn);\n}",
    "receiverBase": "fkNames",
    "receiverCallee": "map"
  },
  {
    "callback": "function (that) {\n    context.property.getAllValidators().forEach(function (validator) {\n        ok = validate(that, validator, value, context) && ok;\n    });\n}",
    "receiverBase": "LIT:this",
    "receiverCallee": "_processValidationOpAndPublish"
  },
  {
    "callback": "function (validator) {\n    ok = validate(that, validator, value, context) && ok;\n}",
    "receiverBase": "getAllValidators",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    removeFromRelationsCore(entity);\n}",
    "receiverBase": "",
    "receiverCallee": "__using"
  },
  {
    "callback": "function (v) {\n    if (inverseNp.isScalar) {\n        v.setProperty(inverseNp.name, null);\n    } else {\n    }\n}",
    "receiverBase": "slice",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (st) {\n    return st.isAbstract === false;\n}",
    "receiverBase": "subtypes",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (kp, i) {\n    if (kp.dataType === DataType.Guid) {\n        keyValues[i] = keyValues[i] && keyValues[i].toLowerCase();\n    }\n}",
    "receiverBase": "keyProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (add) {\n    if (add.entityAspect.entityState.isDetached()) {\n        relationArray._inProgress = true;\n        try {\n            entityManager.attachEntity(add, EntityState.Added);\n        } finally {\n            relationArray._inProgress = false;\n        }\n    }\n}",
    "receiverBase": "goodAdds",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (childEntity) {\n    addsInProcess.push(childEntity);\n    if (invNp) {\n        childEntity.setProperty(invNp.name, parentEntity);\n    } else {\n        var pks = parentEntity.entityType.keyProperties;\n        np.invForeignKeyNames.forEach(function (fk, i) {\n            childEntity.setProperty(fk, parentEntity.getProperty(pks[i].name));\n        });\n    }\n}",
    "receiverBase": "adds",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (fk, i) {\n    childEntity.setProperty(fk, parentEntity.getProperty(pks[i].name));\n}",
    "receiverBase": "invForeignKeyNames",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (childEntity) {\n    childEntity.setProperty(inp.name, null);\n}",
    "receiverBase": "removes",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (a) {\n    if (relationArray._addsInProcess.indexOf(a) >= 0) {\n        return false;\n    }\n    var inverseValue = a.getProperty(inverseProp.name);\n    return inverseValue !== parentEntity;\n}",
    "receiverBase": "adds",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (a) {\n    if (relationArray._addsInProcess.indexOf(a) >= 0) {\n        return false;\n    }\n    return fkPropNames.some(function (fk, i) {\n        var keyProp = keyProps[i].name;\n        var keyVal = parentEntity.getProperty(keyProp);\n        var fkVal = a.getProperty(fk);\n        return keyVal !== fkVal;\n    });\n}",
    "receiverBase": "adds",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (fk, i) {\n    var keyProp = keyProps[i].name;\n    var keyVal = parentEntity.getProperty(keyProp);\n    var fkVal = a.getProperty(fk);\n    return keyVal !== fkVal;\n}",
    "receiverBase": "fkPropNames",
    "receiverCallee": "some"
  },
  {
    "callback": "function (nv) {\n    return dataType.parse(nv, typeof nv);\n}",
    "receiverBase": "newValue",
    "receiverCallee": "map"
  },
  {
    "callback": "function (p) {\n    if (p === property) {\n        return newValue;\n    } else {\n        return parent.getProperty(p.name);\n    }\n}",
    "receiverBase": "keyProps",
    "receiverCallee": "map"
  },
  {
    "callback": "function (np) {\n    var inverseNp = np.inverse;\n    var fkNames = inverseNp ? inverseNp.foreignKeyNames : np.invForeignKeyNames;\n    if (fkNames.length === 0)\n        return;\n    var npValue = parent.getProperty(np.name);\n    var fkName = fkNames[propertyIx];\n    if (np.isScalar) {\n        if (!npValue)\n            return;\n        npValue.setProperty(fkName, newValue);\n    } else {\n        npValue.forEach(function (iv) {\n            iv.setProperty(fkName, newValue);\n        });\n    }\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (iv) {\n    iv.setProperty(fkName, newValue);\n}",
    "receiverBase": "npValue",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (invFkProp) {\n    if (invFkProp.relatedNavigationProperty.inverse == null) {\n        entityManager._updateFkVal(invFkProp, oldValue, newValue);\n    }\n    ;\n}",
    "receiverBase": "inverseForeignKeyProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (dp) {\n    var pn = dp.name;\n    var nv = newValue.getProperty(pn);\n    oldValue.setProperty(pn, nv);\n}",
    "receiverBase": "dataProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (fkName, i) {\n    newValue.setProperty(fkName, pkValues[i]);\n}",
    "receiverBase": "invForeignKeyNames",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (fkName) {\n    var fkProp = oldValue.entityType.getProperty(fkName);\n    if (!fkProp.isPartOfKey) {\n        oldValue.setProperty(fkName, null);\n    }\n}",
    "receiverBase": "invForeignKeyNames",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (keyProp, i) {\n    var relatedDataProp = property.relatedDataProperties[i];\n    if (newValue || !relatedDataProp.isPartOfKey) {\n        var relatedValue = newValue ? newValue.getProperty(keyProp.name) : relatedDataProp.defaultValue;\n        parent.setProperty(relatedDataProp.name, relatedValue);\n    }\n}",
    "receiverBase": "inverseKeyProps",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (sym) {\n    sym.validatorCtor = getValidatorCtor(sym);\n}",
    "receiverBase": "getSymbols",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (ds) {\n    return ds.serviceName === serviceName;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayIndexOf"
  },
  {
    "callback": "function (property) {\n    structuralType._updateNames(property);\n    if (!property.isUnmapped) {\n        structuralType._mappedPropertiesCount++;\n    }\n}",
    "receiverBase": "getProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (ds) {\n    ds = DataService.fromJSON(ds);\n    that.addDataService(ds, true);\n}",
    "receiverBase": "dataServices",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (stype) {\n    structuralTypeFromJson(that, stype, allowMerge);\n}",
    "receiverBase": "structuralTypes",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (ds) {\n    return ds.serviceName === serviceName;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (rawMetadata) {\n    that.metadataFetched.publish({\n        metadataStore: that,\n        dataService: dataService,\n        rawMetadata: rawMetadata\n    });\n    if (callback)\n        callback(rawMetadata);\n    return Q.resolve(rawMetadata);\n}",
    "receiverBase": "fetchMetadata",
    "receiverCallee": "then"
  },
  {
    "callback": "function (error) {\n    if (errorCallback)\n        errorCallback(error);\n    return Q.reject(error);\n}",
    "receiverBase": "fetchMetadata",
    "receiverCallee": "then"
  },
  {
    "callback": "function (key, value) {\n    return value;\n}",
    "receiverBase": "",
    "receiverCallee": "__objectMap"
  },
  {
    "callback": "function (dp) {\n    stype._addPropertyCore(DataProperty.fromJSON(dp));\n}",
    "receiverBase": "dataProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    stype._addPropertyCore(NavigationProperty.fromJSON(np));\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (d) {\n    completeStructuralTypeFromJson(metadataStore, d.json, d.stype);\n}",
    "receiverBase": "deferrals",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (mapping) {\n    newMap[mapping[0]] = mapping[1];\n}",
    "receiverBase": "mappings",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (container) {\n    __toArray(container.entitySet).forEach(function (entitySet) {\n        var entityTypeName = parseTypeName(entitySet.entityType, schema).typeName;\n        metadataStore.setEntityTypeForResourceName(entitySet.name, entityTypeName);\n        metadataStore._entityTypeResourceMap[entityTypeName] = entitySet.name;\n    });\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entitySet) {\n    var entityTypeName = parseTypeName(entitySet.entityType, schema).typeName;\n    metadataStore.setEntityTypeForResourceName(entitySet.name, entityTypeName);\n    metadataStore._entityTypeResourceMap[entityTypeName] = entitySet.name;\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (ct) {\n    var complexType = parseCsdlComplexType(ct, schema, metadataStore);\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (et) {\n    var entityType = parseCsdlEntityType(et, schema, metadataStore);\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    return np.parentType.name + ':' + np.name;\n}",
    "receiverBase": "badNavProps",
    "receiverCallee": "map"
  },
  {
    "callback": "function (prop) {\n    parseCsdlDataProperty(entityType, prop, schema, keyNamesOnServer);\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (prop) {\n    parseCsdlNavProperty(entityType, prop, schema);\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (d) {\n    completeParseCsdlEntityType(d.entityType, d.csdlEntityType, schema, metadataStore);\n}",
    "receiverBase": "deferrals",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (prop) {\n    parseCsdlDataProperty(complexType, prop, schema);\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (assocEnd) {\n    return assocEnd.role === csdlProperty.toRole;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (enumType) {\n    return enumType.name === baseTypeName;\n}",
    "receiverBase": "enumTypes",
    "receiverCallee": "some"
  },
  {
    "callback": "function (ext) {\n    return ext.name === 'EnumType';\n}",
    "receiverBase": "extensions",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (enumType) {\n    return enumType.attributes.some(function (attr) {\n        return attr.name === 'Name' && attr.value === baseTypeName;\n    });\n}",
    "receiverBase": "enumTypes",
    "receiverCallee": "some"
  },
  {
    "callback": "function (attr) {\n    return attr.name === 'Name' && attr.value === baseTypeName;\n}",
    "receiverBase": "attributes",
    "receiverCallee": "some"
  },
  {
    "callback": "function (pn) {\n    return pn.indexOf('StoreGeneratedPattern') >= 0;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (extension) {\n    return extension.name === 'StoreGeneratedPattern' && extension.value === 'Identity';\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (assoc) {\n    return assoc.name === assocName;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (rawTypeName) {\n    return rawTypeName && parseTypeName(rawTypeName).typeName;\n}",
    "receiverBase": "",
    "receiverCallee": "__memoize"
  },
  {
    "callback": "function (st) {\n    var subtypes = st.getSelfAndSubtypes();\n    result.push.apply(result, subtypes);\n}",
    "receiverBase": "subtypes",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (dp) {\n    var newDp = new DataProperty(dp);\n    newDp.validators = [];\n    newDp.baseProperty = dp;\n    this._addPropertyCore(newDp);\n}",
    "receiverBase": "dataProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    var newNp = new NavigationProperty(np);\n    newNp.validators = [];\n    newNp.baseProperty = np;\n    this._addPropertyCore(newNp);\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (kp) {\n    return initialValues[kp.name] != null;\n}",
    "receiverBase": "keyProperties",
    "receiverCallee": "every"
  },
  {
    "callback": "function (v) {\n    relatedEntity = v.entityAspect ? v : navEntityType.createEntity(v);\n    relatedEntities.push(relatedEntity);\n}",
    "receiverBase": "val",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (cp) {\n    var ctInstance = instance.getProperty(cp.name);\n    if (Array.isArray(ctInstance)) {\n        ctInstance.forEach(function (ctInst) {\n            cp.dataType._initializeInstance(ctInst);\n        });\n    } else {\n        cp.dataType._initializeInstance(ctInstance);\n    }\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (ctInst) {\n    cp.dataType._initializeInstance(ctInst);\n}",
    "receiverBase": "ctInstance",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (propName) {\n    var prop = __arrayFirst(parentType.getProperties(), __propEq(key, propName));\n    if (prop) {\n        parentType = prop.isNavigationProperty ? prop.entityType : prop.dataType;\n    } else if (throwIfNotFound) {\n        throw new Error('unable to locate property: ' + propName + ' on entityType: ' + parentType.name);\n    } else {\n        ok = false;\n    }\n    return prop;\n}",
    "receiverBase": "propertyNames",
    "receiverCallee": "map"
  },
  {
    "callback": "function (propName) {\n    return fn(propName);\n}",
    "receiverBase": "split",
    "receiverCallee": "map"
  },
  {
    "callback": "function (prop) {\n    return prop.nameOnServer;\n}",
    "receiverBase": "getPropertiesOnPath",
    "receiverCallee": "map"
  },
  {
    "callback": "function (dp) {\n    var val = rawValueFn(rawEntity, dp);\n    return parseRawValue(val, dp.dataType);\n}",
    "receiverBase": "keyProperties",
    "receiverCallee": "map"
  },
  {
    "callback": "function (rawCo) {\n    var newCo = dataType._createInstanceCore(target, dp);\n    dataType._updateTargetFromRaw(newCo, rawCo, rawValueFn);\n    dataType._initializeInstance(newCo);\n    oldVal.push(newCo);\n}",
    "receiverBase": "rawVal",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (rv) {\n    val = parseRawValue(rv, dataType);\n    oldVal.push(val);\n}",
    "receiverBase": "rawVal",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (prop) {\n    return prop.baseProperty == null;\n}",
    "receiverBase": "props",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (cName) {\n    var sName = nc.clientPropertyNameToServer(cName, parent);\n    var testName = nc.serverPropertyNameToClient(sName, parent);\n    if (cName !== testName) {\n        throw new Error('NamingConvention for this client property name does not roundtrip properly:' + cName + '-->' + testName);\n    }\n    return sName;\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "map"
  },
  {
    "callback": "function (sName) {\n    var cName = nc.serverPropertyNameToClient(sName, parent);\n    var testName = nc.clientPropertyNameToServer(cName, parent);\n    if (sName !== testName) {\n        throw new Error('NamingConvention for this server property name does not roundtrip properly:' + sName + '-->' + testName);\n    }\n    return cName;\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "map"
  },
  {
    "callback": "function (cp) {\n    if (cp.complexType)\n        return;\n    if (!resolveCp(cp, metadataStore)) {\n        __getArray(incompleteTypeMap, cp.complexTypeName).push(cp);\n    }\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (cp) {\n    resolveCp(cp, metadataStore);\n}",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    tryResolveNp(np, metadataStore);\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    tryResolveNp(np, metadataStore);\n}",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (st) {\n    st._addPropertyCore(new DataProperty(newProp));\n}",
    "receiverBase": "getSelfAndSubtypes",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (altNp) {\n    return altNp.associationName === np.associationName && (altNp.name !== np.name || altNp.entityTypeName !== np.entityTypeName);\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (np2) {\n    return np2.invForeignKeyNames && np2.invForeignKeyNames.indexOf(fkProp.name) >= 0 && np2.entityType === fkProp.parentType;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (fkName) {\n    return parentEntityType.getDataProperty(fkName);\n}",
    "receiverBase": "fkNames",
    "receiverCallee": "map"
  },
  {
    "callback": "function (dp) {\n    __arrayAddItemUnique(fkPropCollection, dp);\n    dp.relatedNavigationProperty = np;\n    __arrayAddItemUnique(np.entityType.inverseForeignKeyProperties, dp);\n    if (np.relatedDataProperties) {\n        __arrayAddItemUnique(np.relatedDataProperties, dp);\n    } else {\n        np.relatedDataProperties = [dp];\n    }\n}",
    "receiverBase": "fkProps",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    var ctor = new Enum('AutoGeneratedKeyType');\n    ctor.None = ctor.addSymbol();\n    ctor.Identity = ctor.addSymbol();\n    ctor.KeyGenerator = ctor.addSymbol();\n    ctor.resolveSymbols();\n    return ctor;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (alias) {\n    aliasMap[alias.toLowerCase()] = config;\n}",
    "receiverBase": "aliases",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key) {\n    return createPredicateFromKeyValue(key, obj[key]);\n}",
    "receiverBase": "keys",
    "receiverCallee": "map"
  },
  {
    "callback": "function () {\n    var ctor = function (value) {\n        this.value = value;\n    };\n    var proto = ctor.prototype = new Predicate();\n    proto._initialize('passthruPredicate');\n    proto._validate = __noop;\n    return ctor;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function () {\n    var ctor = function (op, pred) {\n        this.op = this._resolveOp(op);\n        this.pred = Predicate(pred);\n    };\n    var proto = ctor.prototype = new Predicate();\n    proto._initialize('unaryPredicate', {\n        'not': {\n            aliases: [\n                '!',\n                '~'\n            ]\n        }\n    });\n    proto._validate = function (entityType, usesNameOnServer) {\n        this.pred._validate(entityType, usesNameOnServer);\n    };\n    return ctor;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (pred) {\n    return pred != null;\n}",
    "receiverBase": "preds",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (pred) {\n    return Predicate(pred);\n}",
    "receiverBase": "filter",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pred) {\n    pred._validate(entityType, usesNameOnServer);\n}",
    "receiverBase": "preds",
    "receiverCallee": "every"
  },
  {
    "callback": "function (v) {\n    return dataType.parse(v, typeof v);\n}",
    "receiverBase": "value",
    "receiverCallee": "map"
  },
  {
    "callback": "function (expr) {\n    expr._validate(entityType, usesNameOnServer);\n}",
    "receiverBase": "exprs",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (a) {\n    return parseExpr(a, tokens, newContext);\n}",
    "receiverBase": "args",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pred) {\n    return pred.visit(context);\n}",
    "receiverBase": "preds",
    "receiverCallee": "map"
  },
  {
    "callback": "function (prev, cur) {\n    return prev && cur(entity);\n}",
    "receiverBase": "predFns",
    "receiverCallee": "reduce"
  },
  {
    "callback": "function (prev, cur) {\n    return prev || cur(entity);\n}",
    "receiverBase": "predFns",
    "receiverCallee": "reduce"
  },
  {
    "callback": "function (expr) {\n    return expr.visit(context);\n}",
    "receiverBase": "exprs",
    "receiverCallee": "map"
  },
  {
    "callback": "function (exprFn) {\n    var value = exprFn(entity);\n    return value;\n}",
    "receiverBase": "exprFns",
    "receiverCallee": "map"
  },
  {
    "callback": "function (v) {\n    return v2(v);\n}",
    "receiverBase": "v1",
    "receiverCallee": "some"
  },
  {
    "callback": "function (v) {\n    return v2(v);\n}",
    "receiverBase": "v1",
    "receiverCallee": "every"
  },
  {
    "callback": "function (v) {\n    return mc(v);\n}",
    "receiverBase": "v2",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pred) {\n    return pred.visit(context);\n}",
    "receiverBase": "preds",
    "receiverCallee": "map"
  },
  {
    "callback": "function (expr) {\n    return expr.visit(context);\n}",
    "receiverBase": "exprs",
    "receiverCallee": "map"
  },
  {
    "callback": "function (key) {\n    if (j1.hasOwnProperty(key)) {\n        if (typeof j2[key] != 'object') {\n            return false;\n        }\n        if (combine(j1[key], j2[key]) == null) {\n            return false;\n        }\n    } else {\n        j1[key] = j2[key];\n    }\n    return true;\n}",
    "receiverBase": "keys",
    "receiverCallee": "every"
  },
  {
    "callback": "function (entity) {\n    return buildPredicate(entity);\n}",
    "receiverBase": "entities",
    "receiverCallee": "map"
  },
  {
    "callback": "function (propName, val) {\n    processUsing(eq, map, val, propName);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (pp) {\n    return pp.trim();\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function (kp) {\n    return Predicate.create(kp.name, FilterQueryOp.Equals, entity.getProperty(kp.name));\n}",
    "receiverBase": "keyProperties",
    "receiverCallee": "map"
  },
  {
    "callback": "function (kp, v) {\n    return Predicate.create(kp.name, FilterQueryOp.Equals, v);\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayZip"
  },
  {
    "callback": "function (fkName) {\n    return entity.getProperty(fkName);\n}",
    "receiverBase": "foreignKeyNames",
    "receiverCallee": "map"
  },
  {
    "callback": "function (fkName, kv) {\n    return Predicate.create(fkName, FilterQueryOp.Equals, kv);\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayZip"
  },
  {
    "callback": "function () {\n    var map = {};\n    aEnum.getSymbols().forEach(function (s) {\n        map[s.name.toLowerCase()] = s;\n        map[s.operator.toLowerCase()] = s;\n        if (s.aliases) {\n            s.aliases.forEach(function (alias) {\n                map[alias.toLowerCase()] = s;\n            });\n        }\n    });\n    return map;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (s) {\n    map[s.name.toLowerCase()] = s;\n    map[s.operator.toLowerCase()] = s;\n    if (s.aliases) {\n        s.aliases.forEach(function (alias) {\n            map[alias.toLowerCase()] = s;\n        });\n    }\n}",
    "receiverBase": "getSymbols",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (alias) {\n    map[alias.toLowerCase()] = s;\n}",
    "receiverBase": "aliases",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    var map = {};\n    aEnum.getSymbols().forEach(function (s) {\n        map[s.name.toLowerCase()] = s;\n        map[s.operator.toLowerCase()] = s;\n        if (s.aliases) {\n            s.aliases.forEach(function (alias) {\n                map[alias.toLowerCase()] = s;\n            });\n        }\n    });\n    return map;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (s) {\n    map[s.name.toLowerCase()] = s;\n    map[s.operator.toLowerCase()] = s;\n    if (s.aliases) {\n        s.aliases.forEach(function (alias) {\n            map[alias.toLowerCase()] = s;\n        });\n    }\n}",
    "receiverBase": "getSymbols",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (alias) {\n    map[alias.toLowerCase()] = s;\n}",
    "receiverBase": "aliases",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (pp) {\n    return new OrderByItem(pp, isDesc);\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function (item) {\n    item.validate(entityType);\n}",
    "receiverBase": "items",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (obc) {\n    return obc.getComparer(entityType);\n}",
    "receiverBase": "items",
    "receiverCallee": "map"
  },
  {
    "callback": "function (item) {\n    return context.propertyPathFn(item.propertyPath) + (item.isDesc ? ' desc' : '');\n}",
    "receiverBase": "items",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pp) {\n    return pp.replace('.', '_');\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function (path) {\n    entityType.getProperty(path, true);\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (path, i) {\n    result[that._pathNames[i]] = getPropertyPathValue(entity, path);\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (pp) {\n    return context.propertyPathFn(pp);\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function () {\n    var ctor = function (propertyPaths) {\n        this.propertyPaths = propertyPaths;\n    };\n    var proto = ctor.prototype;\n    proto.toJSONExt = function (context) {\n        return this.propertyPaths.map(function (pp) {\n            return context.propertyPathFn(pp);\n        });\n    };\n    return ctor;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (pp) {\n    return context.propertyPathFn(pp);\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function (prop) {\n    nextValue = nextValue.getProperty(prop);\n    return nextValue == null;\n}",
    "receiverBase": "properties",
    "receiverCallee": "some"
  },
  {
    "callback": "function () {\n    var MergeStrategy = new Enum('MergeStrategy');\n    MergeStrategy.PreserveChanges = MergeStrategy.addSymbol();\n    MergeStrategy.OverwriteChanges = MergeStrategy.addSymbol();\n    MergeStrategy.SkipMerge = MergeStrategy.addSymbol();\n    MergeStrategy.Disallowed = MergeStrategy.addSymbol();\n    MergeStrategy.resolveSymbols();\n    return MergeStrategy;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function () {\n    var FetchStrategy = new Enum('FetchStrategy');\n    FetchStrategy.FromServer = FetchStrategy.addSymbol();\n    FetchStrategy.FromLocalCache = FetchStrategy.addSymbol();\n    FetchStrategy.resolveSymbols();\n    return FetchStrategy;\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (entity) {\n    if (entity != null) {\n        entity.entityAspect._detach();\n    }\n}",
    "receiverBase": "_entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entity) {\n    if (entity != null) {\n        if (entity.getProperty(fkPropName) == oldValue) {\n            entity.setProperty(fkPropName, newValue);\n        }\n    }\n}",
    "receiverBase": "_entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (es) {\n    return e.entityAspect.entityState === es;\n}",
    "receiverBase": "entityStates",
    "receiverCallee": "some"
  },
  {
    "callback": "function () {\n    entity = entityType.createEntity(initialValues);\n}",
    "receiverBase": "",
    "receiverCallee": "__using"
  },
  {
    "callback": "function (entity) {\n    entity.entityAspect.acceptChanges();\n}",
    "receiverBase": "getChanges",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (k) {\n    var oldKey = EntityKey.fromJSON(k, that.metadataStore);\n    tempKeyMap[oldKey.toString()] = new EntityKey(oldKey.entityType, that.keyGenerator.generateTempKeyValue(oldKey.entityType, oldKey.values[0]));\n}",
    "receiverBase": "tempKeys",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    that._pendingPubs = [];\n}",
    "receiverBase": "",
    "receiverCallee": "__wrapExecution"
  },
  {
    "callback": "function (state) {\n    that._pendingPubs.forEach(function (fn) {\n        fn();\n    });\n    that._pendingPubs = null;\n    that._hasChangesAction && that._hasChangesAction();\n}",
    "receiverBase": "",
    "receiverCallee": "__wrapExecution"
  },
  {
    "callback": "function (fn) {\n    fn();\n}",
    "receiverBase": "_pendingPubs",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    __objectForEach(json.entityGroupMap, function (entityTypeName, jsonGroup) {\n        var entityType = that.metadataStore._getEntityType(entityTypeName, true);\n        var targetEntityGroup = findOrCreateEntityGroup(that, entityType);\n        var entities = importEntityGroup(targetEntityGroup, jsonGroup, config);\n        Array.prototype.push.apply(entitiesToLink, entities);\n    });\n    entitiesToLink.forEach(function (entity) {\n        that._linkRelatedEntities(entity);\n    });\n}",
    "receiverBase": "",
    "receiverCallee": "__wrapExecution"
  },
  {
    "callback": "function (entityTypeName, jsonGroup) {\n    var entityType = that.metadataStore._getEntityType(entityTypeName, true);\n    var targetEntityGroup = findOrCreateEntityGroup(that, entityType);\n    var entities = importEntityGroup(targetEntityGroup, jsonGroup, config);\n    Array.prototype.push.apply(entitiesToLink, entities);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (entity) {\n    that._linkRelatedEntities(entity);\n}",
    "receiverBase": "entitiesToLink",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key, entityGroup) {\n    entityGroup._clear();\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function () {\n    if (entityState.isAdded()) {\n        checkEntityKey(that, entity);\n    }\n    attachedEntity = that._attachEntityCore(entity, entityState, mergeStrategy);\n    aspect._inProcessEntity = attachedEntity;\n    try {\n        attachRelatedEntities(that, entity, entityState, mergeStrategy);\n    } finally {\n        aspect._inProcessEntity = null;\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "__using"
  },
  {
    "callback": "function () {\n    return executeQueryCore(that, query, queryOptions, dataService);\n}",
    "receiverBase": "fetchMetadata",
    "receiverCallee": "then"
  },
  {
    "callback": "function (group) {\n    result.push.apply(result, group._entities.filter(newFilterFunc));\n}",
    "receiverBase": "groups",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entity) {\n    return entity.entityAspect.isBeingSaved;\n}",
    "receiverBase": "entitiesToSave",
    "receiverCallee": "some"
  },
  {
    "callback": "function (entity) {\n    var aspect = entity.entityAspect;\n    var isValid = aspect.entityState.isDeleted() || aspect.validateEntity();\n    return !isValid;\n}",
    "receiverBase": "entitiesToSave",
    "receiverCallee": "filter"
  },
  {
    "callback": "function () {\n    var mappingContext = new MappingContext({\n            query: null,\n            entityManager: em,\n            mergeOptions: { mergeStrategy: MergeStrategy.OverwriteChanges },\n            dataService: dataService\n        });\n    savedEntities = mappingContext.visitAndMerge(savedEntities, { nodeType: 'root' });\n}",
    "receiverBase": "",
    "receiverCallee": "__using"
  },
  {
    "callback": "function (entity) {\n    var serverKeys = [];\n    var aspect = entity.entityAspect;\n    __objectForEach(aspect._validationErrors, function (key, ve) {\n        if (ve.isServerError)\n            serverKeys.push(key);\n    });\n    if (serverKeys.length === 0)\n        return;\n    aspect._processValidationOpAndPublish(function () {\n        serverKeys.forEach(function (key) {\n            aspect._removeValidationError(key);\n        });\n    });\n}",
    "receiverBase": "entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key, ve) {\n    if (ve.isServerError)\n        serverKeys.push(key);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function () {\n    serverKeys.forEach(function (key) {\n        aspect._removeValidationError(key);\n    });\n}",
    "receiverBase": "aspect",
    "receiverCallee": "_processValidationOpAndPublish"
  },
  {
    "callback": "function (key) {\n    aspect._removeValidationError(key);\n}",
    "receiverBase": "serverKeys",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entity) {\n    __objectForEach(entity.entityAspect._validationErrors, function (key, ve) {\n        var cfg = __extend({\n                entity: entity,\n                errorName: ve.validator.name\n            }, ve, [\n                'errorMessage',\n                'propertyName',\n                'isServerError'\n            ]);\n        entityErrors.push(cfg);\n    });\n}",
    "receiverBase": "entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key, ve) {\n    var cfg = __extend({\n            entity: entity,\n            errorName: ve.validator.name\n        }, ve, [\n            'errorMessage',\n            'propertyName',\n            'isServerError'\n        ]);\n    entityErrors.push(cfg);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (et) {\n    var group = this._findEntityGroup(et);\n    ek = group && group.findEntityByKey(entityKey);\n    return ek;\n}",
    "receiverBase": "entityTypes",
    "receiverCallee": "some"
  },
  {
    "callback": "function () {\n    return fetchEntityByKeyCore(that, args);\n}",
    "receiverBase": "fetchMetadata",
    "receiverCallee": "then"
  },
  {
    "callback": "function (data) {\n    entity = data.results.length === 0 ? null : data.results[0];\n    return Q.resolve({\n        entity: entity,\n        entityKey: entityKey,\n        fromCache: false\n    });\n}",
    "receiverBase": "execute",
    "receiverCallee": "then"
  },
  {
    "callback": "function (eg) {\n    return eg.hasChanges();\n}",
    "receiverBase": "entityGroups",
    "receiverCallee": "some"
  },
  {
    "callback": "function (e) {\n    e.entityAspect.rejectChanges();\n}",
    "receiverBase": "changes",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (e) {\n    return e.entityAspect.entityState !== EntityState.Detached;\n}",
    "receiverBase": "children",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (child) {\n    currentChildren.push(child);\n    child.setProperty(childToParentNp.name, entity);\n}",
    "receiverBase": "unattachedChildren",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (child) {\n    currentChildren._push(child);\n}",
    "receiverBase": "unattachedChildren",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (child) {\n    child.setProperty(childToParentNp.name, entity);\n}",
    "receiverBase": "unattachedChildren",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    if (np.isScalar) {\n        var value = entity.getProperty(np.name);\n        if (value)\n            return;\n    }\n    var parentKey = entityAspect.getParentKey(np);\n    if (parentKey) {\n        if (parentKey._isEmpty())\n            return;\n        var parent = em.findEntityByKey(parentKey);\n        if (parent) {\n            entity.setProperty(np.name, parent);\n        } else {\n            unattachedMap.addChild(parentKey, np, entity);\n        }\n    }\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (etName) {\n    return em.metadataStore._getEntityType(etName, false);\n}",
    "receiverBase": "entityTypes",
    "receiverCallee": "map"
  },
  {
    "callback": "function (eg) {\n    if (!eg)\n        return;\n    var entities = eg.getEntities(entityStates);\n    if (selected) {\n        selected.push.apply(selected, entities);\n    } else {\n        selected = entities;\n    }\n}",
    "receiverBase": "entityGroups",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entity) {\n    entity.entityAspect.isBeingSaved = flag;\n}",
    "receiverBase": "entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (e) {\n    var group = entityGroupMap[e.entityType.name];\n    if (!group) {\n        group = {};\n        group.entityType = e.entityType;\n        group._entities = [];\n        entityGroupMap[e.entityType.name] = group;\n    }\n    group._entities.push(e);\n}",
    "receiverBase": "entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entityTypeName, entityGroup) {\n    newGroupMap[entityTypeName] = exportEntityGroup(entityGroup, tempKeys);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (entity) {\n    if (entity) {\n        var rawEntity = structuralObjectToJson(entity, dps, serializerFn, tempKeys);\n        rawEntities.push(rawEntity);\n    }\n}",
    "receiverBase": "_entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (v) {\n    return structuralObjectToJson(v, coDps, serializerFn);\n}",
    "receiverBase": "",
    "receiverCallee": "__map"
  },
  {
    "callback": "function (np) {\n    if (np.relatedDataProperties) {\n        var relatedValue = entity.getProperty(np.name);\n        if (relatedValue && relatedValue.entityAspect.hasTempKey) {\n            tempNavPropNames = tempNavPropNames || [];\n            tempNavPropNames.push(np.name);\n        }\n    }\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (npName) {\n    var np = entityType.getNavigationProperty(npName);\n    var fkPropName = np.relatedDataProperties[0].name;\n    var oldFkValue = targetEntity.getProperty(fkPropName);\n    var fk = new EntityKey(np.entityType, [oldFkValue]);\n    var newFk = getMappedKey(tempKeyMap, fk);\n    targetEntity.setProperty(fkPropName, newFk.values[0]);\n}",
    "receiverBase": "tempNavPropNames",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (data) {\n    if (callback)\n        callback(data);\n    return Q.resolve(data);\n}",
    "receiverBase": "promise",
    "receiverCallee": "then"
  },
  {
    "callback": "function (error) {\n    if (errorCallback)\n        errorCallback(error);\n    return Q.reject(error);\n}",
    "receiverBase": "promise",
    "receiverCallee": "then"
  },
  {
    "callback": "function (e) {\n    if (e.entityAspect.entityManager !== em) {\n        throw new Error('Only entities in this entityManager may be saved');\n    }\n    return !e.entityAspect.entityState.isDetached();\n}",
    "receiverBase": "entities",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (km) {\n    var group = em._entityGroupMap[km.entityTypeName];\n    if (!group) {\n        throw new Error('Unable to locate the following fully qualified EntityType name: ' + km.entityTypeName);\n    }\n    group._fixupKey(km.tempValue, km.realValue);\n}",
    "receiverBase": "keyMappings",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (et) {\n    if (et instanceof EntityType) {\n        return groupMap[et.name];\n    } else {\n        throw new Error('The EntityManager.getChanges() \\'entityTypes\\' parameter must be either an entityType or an array of entityTypes or null');\n    }\n}",
    "receiverBase": "__toArray",
    "receiverCallee": "map"
  },
  {
    "callback": "function (kp, kv) {\n    return kp.defaultValue === kv ? kp : null;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayZip"
  },
  {
    "callback": "function (kp) {\n    return kp !== null;\n}",
    "receiverBase": "__arrayZip",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (es) {\n    if (!EntityState.contains(es)) {\n        throw new Error('The EntityManager.getChanges() \\'entityStates\\' parameter must either be null, an entityState or an array of entityStates');\n    }\n}",
    "receiverBase": "entityStates",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    var related = entity.getProperty(np.name);\n    if (np.isScalar) {\n        if (!related)\n            return;\n        em.attachEntity(related, entityState, mergeStrategy);\n    } else {\n        related.forEach(function (e) {\n            em.attachEntity(e, entityState, mergeStrategy);\n        });\n    }\n}",
    "receiverBase": "navProps",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (e) {\n    em.attachEntity(e, entityState, mergeStrategy);\n}",
    "receiverBase": "related",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    var state = { isLoading: em.isLoading };\n    em.isLoading = true;\n    em._pendingPubs = [];\n    return state;\n}",
    "receiverBase": "",
    "receiverCallee": "__wrapExecution"
  },
  {
    "callback": "function (state) {\n    em.isLoading = state.isLoading;\n    em._pendingPubs.forEach(function (fn) {\n        fn();\n    });\n    em._pendingPubs = null;\n    em._hasChangesAction && em._hasChangesAction();\n    query = null;\n    mappingContext = null;\n    if (state.error) {\n        Q.reject(state.error);\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "__wrapExecution"
  },
  {
    "callback": "function (fn) {\n    fn();\n}",
    "receiverBase": "_pendingPubs",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (r) {\n    r.entityAspect && r.entityAspect.validateEntity();\n}",
    "receiverBase": "results",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (e) {\n    if (e) {\n        e.query = query;\n        e.entityManager = em;\n    }\n    return Q.reject(e);\n}",
    "receiverBase": "executeQuery",
    "receiverCallee": "then"
  },
  {
    "callback": "function (propertyPath) {\n    var propNames = propertyPath.split('.');\n    markLoadedNavPath(entities, propNames);\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (entity) {\n    var ea = entity.entityAspect;\n    if (!ea)\n        return;\n    ea._markAsLoaded(propName);\n    if (propNames.length === 1)\n        return;\n    var next = entity.getProperty(propName);\n    if (!next)\n        return;\n    if (!next.arrayChanged)\n        next = [next];\n    markLoadedNavPath(next, propNames.slice(1));\n}",
    "receiverBase": "entities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (e) {\n    e.entityAspect.isBeingSaved = true;\n    return e.entityAspect.entityState.isModified() && e.entityType.concurrencyProperties.length > 0;\n}",
    "receiverBase": "entities",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (c) {\n    c.entityType.concurrencyProperties.forEach(function (cp) {\n        updateConcurrencyProperty(c, cp);\n    });\n}",
    "receiverBase": "candidates",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (cp) {\n    updateConcurrencyProperty(c, cp);\n}",
    "receiverBase": "concurrencyProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (et) {\n    return findOrCreateEntityGroup(em, et);\n}",
    "receiverBase": "entityTypes",
    "receiverCallee": "map"
  },
  {
    "callback": "function (co) {\n    return unwrapInstance(co, transformFn);\n}",
    "receiverBase": "",
    "receiverCallee": "__map"
  },
  {
    "callback": "function (propName, val) {\n    var prop = stype.getProperty(propName);\n    val = transformFn ? transformFn(prop, val) : val;\n    if (val !== undefined) {\n        result[fn(propName, prop)] = val;\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (cp) {\n    var nextTarget = target.getProperty(cp.name);\n    if (cp.isScalar) {\n        var unwrappedCo = unwrapOriginalValues(nextTarget, metadataStore, transformFn);\n        if (!__isEmpty(unwrappedCo)) {\n            result[fn(cp.name, cp)] = unwrappedCo;\n        }\n    } else {\n        var unwrappedCos = nextTarget.map(function (item) {\n                return unwrapOriginalValues(item, metadataStore, transformFn);\n            });\n        result[fn(cp.name, cp)] = unwrappedCos;\n    }\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (item) {\n    return unwrapOriginalValues(item, metadataStore, transformFn);\n}",
    "receiverBase": "nextTarget",
    "receiverCallee": "map"
  },
  {
    "callback": "function (propName, value) {\n    var prop = stype.getProperty(propName);\n    var val = entity.getProperty(propName);\n    val = transformFn ? transformFn(prop, val) : val;\n    if (val === undefined)\n        return;\n    val = serializerFn ? serializerFn(prop, val) : val;\n    if (val !== undefined) {\n        result[fn(propName, prop)] = val;\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (cp) {\n    if (cpHasOriginalValues(entity, cp)) {\n        var coOrCos = entity.getProperty(cp.name);\n        result[fn(cp.name, cp)] = __map(coOrCos, function (co) {\n            return unwrapInstance(co, transformFn);\n        });\n    }\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (co) {\n    return unwrapInstance(co, transformFn);\n}",
    "receiverBase": "",
    "receiverCallee": "__map"
  },
  {
    "callback": "function (co) {\n    return coHasOriginalValues(co);\n}",
    "receiverBase": "coOrCos",
    "receiverCallee": "some"
  },
  {
    "callback": "function (cp) {\n    return cpHasOriginalValues(co, cp);\n}",
    "receiverBase": "complexProperties",
    "receiverCallee": "some"
  },
  {
    "callback": "function (t) {\n    return t.navigationProperty === navigationProperty;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayRemoveItem"
  },
  {
    "callback": "function (child) {\n    return !child.entityAspect.entityState.isDetached();\n}",
    "receiverBase": "children",
    "receiverCallee": "filter"
  },
  {
    "callback": "function (t) {\n    return t.navigationProperty === navigationProperty;\n}",
    "receiverBase": "",
    "receiverCallee": "__arrayFirst"
  },
  {
    "callback": "function (fn) {\n    fn();\n}",
    "receiverBase": "deferredFns",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    assignFn(refValue);\n}",
    "receiverBase": "deferredFns",
    "receiverCallee": "push"
  },
  {
    "callback": "function (dp) {\n    if (dp.isComplexProperty) {\n        result[dp.name] = __map(node[dp.nameOnServer], function (v) {\n            return processNoMerge(mc, dp.dataType, v);\n        });\n    } else {\n        result[dp.name] = parseRawValue(node[dp.nameOnServer], dp.dataType);\n    }\n}",
    "receiverBase": "dataProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (v) {\n    return processNoMerge(mc, dp.dataType, v);\n}",
    "receiverBase": "",
    "receiverCallee": "__map"
  },
  {
    "callback": "function (np) {\n    var nodeContext = {\n            nodeType: 'navProp',\n            navigationProperty: np\n        };\n    visitNode(node[np.nameOnServer], mc, nodeContext, result, np.name);\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (key, value) {\n    var newKey = keyFn(key);\n    var nodeContext = {\n            nodeType: 'anonProp',\n            propertyName: newKey\n        };\n    visitNode(value, mc, nodeContext, result, newKey);\n}",
    "receiverBase": "",
    "receiverCallee": "__objectForEach"
  },
  {
    "callback": "function (v, ix) {\n    meta = jra.visitNode(v, mc, nodeContext) || {};\n    v = meta.node || v;\n    return processMeta(mc, v, meta, function (refValue) {\n        result[key][ix] = refValue();\n    });\n}",
    "receiverBase": "node",
    "receiverCallee": "map"
  },
  {
    "callback": "function (refValue) {\n    result[key][ix] = refValue();\n}",
    "receiverBase": "",
    "receiverCallee": "processMeta"
  },
  {
    "callback": "function (refValue) {\n    result[key] = refValue();\n}",
    "receiverBase": "",
    "receiverCallee": "processMeta"
  },
  {
    "callback": "function (np) {\n    if (np.isScalar) {\n        mergeRelatedEntityCore(mc, node, np);\n    } else {\n        mergeRelatedEntitiesCore(mc, node, np);\n    }\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (np) {\n    if (np.isScalar) {\n        mergeRelatedEntity(mc, np, targetEntity, node);\n    } else {\n        mergeRelatedEntities(mc, np, targetEntity, node);\n    }\n}",
    "receiverBase": "navigationProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    relatedEntity = relatedEntity();\n    updateRelatedEntity(relatedEntity, targetEntity, navigationProperty);\n}",
    "receiverBase": "deferredFns",
    "receiverCallee": "push"
  },
  {
    "callback": "function (relatedEntity) {\n    if (typeof relatedEntity === 'function') {\n        mc.deferredFns.push(function () {\n            relatedEntity = relatedEntity();\n            updateRelatedEntityInCollection(relatedEntity, originalRelatedEntities, targetEntity, inverseProperty);\n        });\n    } else {\n        updateRelatedEntityInCollection(relatedEntity, originalRelatedEntities, targetEntity, inverseProperty);\n    }\n}",
    "receiverBase": "relatedEntities",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function () {\n    relatedEntity = relatedEntity();\n    updateRelatedEntityInCollection(relatedEntity, originalRelatedEntities, targetEntity, inverseProperty);\n}",
    "receiverBase": "deferredFns",
    "receiverCallee": "push"
  },
  {
    "callback": "function (e) {\n    return {\n        errorName: e.ErrorName,\n        entityTypeName: MetadataStore.normalizeTypeName(e.EntityTypeName),\n        keyValues: e.KeyValues,\n        propertyName: e.PropertyName && propNameFn(e.PropertyName),\n        errorMessage: e.ErrorMessage\n    };\n}",
    "receiverBase": "entityErrors",
    "receiverCallee": "map"
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd']) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd']) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd'] && !breeze) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (data, response) {\n    var inlineCount;\n    if (data.__count) {\n        inlineCount = parseInt(data.__count, 10);\n    }\n    return deferred.resolve({\n        results: data.results,\n        inlineCount: inlineCount,\n        httpResponse: response\n    });\n}",
    "receiverBase": "OData",
    "receiverCallee": "read"
  },
  {
    "callback": "function (error) {\n    return deferred.reject(createError(error, url));\n}",
    "receiverBase": "OData",
    "receiverCallee": "read"
  },
  {
    "callback": "function (error) {\n    var err = createError(error, url);\n    err.message = 'Metadata query failed for: ' + url + '; ' + (err.message || '');\n    return deferred.reject(err);\n}",
    "receiverBase": "OData",
    "receiverCallee": "read"
  },
  {
    "callback": "function (err) {\n    return deferred.reject(createError(err, url));\n}",
    "receiverBase": "OData",
    "receiverCallee": "request"
  },
  {
    "callback": "function (kp) {\n    uriKey = uriKey + delim + kp.nameOnServer + '=' + fmtProperty(kp, aspect);\n    delim = ',';\n}",
    "receiverBase": "kps",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd'] && !breeze) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (km) {\n    var entityTypeName = MetadataStore.normalizeTypeName(km.EntityTypeName);\n    return {\n        entityTypeName: entityTypeName,\n        tempValue: km.TempValue,\n        realValue: km.RealValue\n    };\n}",
    "receiverBase": "KeyMappings",
    "receiverCallee": "map"
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd'] && !breeze) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (prop) {\n    var propName = prop.name;\n    if (alreadyWrapped[propName])\n        return;\n    var descr;\n    if (propName in proto) {\n        descr = wrapPropDescription(proto, prop);\n    } else {\n        descr = makePropDescription(proto, prop);\n    }\n    if (descr != null) {\n        Object.defineProperty(proto, propName, descr);\n    }\n    alreadyWrapped[propName] = true;\n}",
    "receiverBase": "getProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (prop) {\n    var propName = prop.name;\n    if (!instance.hasOwnProperty(propName))\n        return;\n    var value = instance[propName];\n    delete instance[propName];\n    instance[propName] = value;\n}",
    "receiverBase": "getProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (pending) {\n    return pending.entity === instance;\n}",
    "receiverBase": "core",
    "receiverCallee": "arrayFirst"
  },
  {
    "callback": "function (pending) {\n    pending.entity._backingStore = pending.backingStore;\n}",
    "receiverBase": "pendingStores",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd'] && !breeze) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (prop) {\n    var propDescr = getES5PropDescriptor(proto, prop.name);\n    if (propDescr) {\n        es5Descriptors[prop.name] = propDescr;\n    }\n}",
    "receiverBase": "getProperties",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (p1, p2) {\n    var v1 = p1.isUnmapped ? 1 : 0;\n    var v2 = p2.isUnmapped ? 1 : 0;\n    return v1 - v2;\n}",
    "receiverBase": "getProperties",
    "receiverCallee": "sort"
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd'] && !breeze) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (factory) {\n    if (breeze) {\n        factory(breeze);\n    } else if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n        factory(require('breeze'));\n    } else if (typeof define === 'function' && define['amd'] && !breeze) {\n        define(['breeze'], factory);\n    }\n}",
    "receiverBase": ""
  },
  {
    "callback": "function (item) {\n    return entityType.clientPropertyPathToServer(item.propertyPath, '/') + (item.isDesc ? ' desc' : '');\n}",
    "receiverBase": "items",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pp) {\n    return entityType.clientPropertyPathToServer(pp, '/');\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pp) {\n    return entityType.clientPropertyPathToServer(pp, '/');\n}",
    "receiverBase": "propertyPaths",
    "receiverCallee": "map"
  },
  {
    "callback": "function (qov) {\n    qoStrings.push(qoName + '=' + encodeURIComponent(qov));\n}",
    "receiverBase": "qoValue",
    "receiverCallee": "forEach"
  },
  {
    "callback": "function (v) {\n    return '(' + expr1Val + ' eq ' + v + ')';\n}",
    "receiverBase": "expr2Val",
    "receiverCallee": "map"
  },
  {
    "callback": "function (pred) {\n    var predVal = pred.visit(context);\n    return '(' + predVal + ')';\n}",
    "receiverBase": "preds",
    "receiverCallee": "map"
  },
  {
    "callback": "function (v) {\n    return this.dataType.fmtOData(v);\n}",
    "receiverBase": "value",
    "receiverCallee": "map"
  },
  {
    "callback": "function (expr) {\n    return expr.visit(context);\n}",
    "receiverBase": "exprs",
    "receiverCallee": "map"
  },
  {
    "callback": "function () {\n    if (this.checked) {\n        align = this.value;\n        return false;\n    }\n}",
    "receiverBase": "alignBox",
    "receiverCallee": "each"
  },
  {
    "callback": "function (e) {\n    localUrlBox.val(uploadbutton.fileBox.val());\n}",
    "receiverBase": "fileBox",
    "receiverCallee": "change"
  },
  {
    "callback": "function () {\n    self.plugin.filemanagerDialog({\n        viewType: 'VIEW',\n        dirName: 'image',\n        clickFn: function (url, title) {\n            if (self.dialogs.length > 1) {\n                K('[name=\"url\"]', div).val(url);\n                if (self.afterSelectFile) {\n                    self.afterSelectFile.call(self, url);\n                }\n                self.hideDialog();\n            }\n        }\n    });\n}",
    "receiverBase": "self",
    "receiverCallee": "loadPlugin"
  },
  {
    "callback": "function (e) {\n    var tempImg = K('<img src=\"' + urlBox.val() + '\" />', document).css({\n            position: 'absolute',\n            visibility: 'hidden',\n            top: 0,\n            left: '-1000px'\n        });\n    tempImg.bind('load', function () {\n        setSize(tempImg.width(), tempImg.height());\n        tempImg.remove();\n    });\n    K(document.body).append(tempImg);\n}",
    "receiverBase": "refreshBtn",
    "receiverCallee": "click"
  },
  {
    "callback": "function () {\n    setSize(tempImg.width(), tempImg.height());\n    tempImg.remove();\n}",
    "receiverBase": "tempImg",
    "receiverCallee": "bind"
  },
  {
    "callback": "function (e) {\n    if (originalWidth > 0) {\n        heightBox.val(Math.round(originalHeight / originalWidth * parseInt(this.value, 10)));\n    }\n}",
    "receiverBase": "widthBox",
    "receiverCallee": "change"
  },
  {
    "callback": "function (e) {\n    if (originalHeight > 0) {\n        widthBox.val(Math.round(originalWidth / originalHeight * parseInt(this.value, 10)));\n    }\n}",
    "receiverBase": "heightBox",
    "receiverCallee": "change"
  },
  {
    "callback": "function () {\n    if (this.value === options.imageAlign) {\n        this.checked = true;\n        return false;\n    }\n}",
    "receiverBase": "alignBox",
    "receiverCallee": "each"
  },
  {
    "callback": "function () {\n    self.hideDialog().focus();\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  },
  {
    "callback": "function () {\n    setTimeout(function () {\n        if (!me.isHidden()) {\n            me._fill();\n        }\n    });\n}",
    "receiverBase": "domUtils",
    "receiverCallee": "on"
  },
  {
    "callback": "function () {\n    if (!me.isHidden()) {\n        me._fill();\n    }\n}",
    "receiverBase": "",
    "receiverCallee": "setTimeout"
  }
]